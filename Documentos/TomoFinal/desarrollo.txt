El diseño e implementación de la infraestructura se inició con la definición de la base de datos, en ella se debe reflejar las relaciones entre los distintos tópicos de la cátedra Sistemas Distribuidos y las aplicaciones que cada uno puede tener. A su vez, debe contener  tablas que permitan conocer la información de la aplicación que se encuentra en ejecución, los agentes de configuración y los mensajes enviados entre los nodos. Por ello, se definieron las siguientes tablas:

<colocarlo en tabla?>:

1. Usuarios: Se elaboró la tabla usuarios debido a que la infraestructura se encuentra diseñada para que los usuarios, en este caso profesores de la cátedra puedan realizar las operaciones tradicionales: Crear, consultar, modificar y eliminar los datos contenidos en las demás tablas de la infraestructura a través del módulo de gestión. La tabla contiene los atributos: Nombre, apellido, correo electrónico (email) y contraseña.

2. Tópicos: Permite almacenar todos los tópicos de la cátedra Sistemas Distribuidos, sus atributos son: Nombre, categoría ('Introducción a los sistemas distribuidos, etc), descripción del tópico y ruta de la imagen (opcional).

3. Preguntas: Almacena el enunciado de las preguntas asociados a un tópico particular.

4. Respuestas: Guarda cada opción disponible para una pregunta y se puede indicar si es opción correcta.

5. Aplicaciones: La tabla aplicación permite asociar distintas aplicaciones para un tópico específico, posee los siguientes atributos: Nombre, fecha de actualización y las instrucciones de uso.

6. Escenario: Permite explicar el objetivo de la aplicación, que sucede cuando ocurre un evento particular. Atributos: Nombre, descripción del escenario e imagen (opcional).

7. Ejecutable: Almacena la información en la relación a los ejecutables que se utilizarán para una aplicación determinada, posee los atributos: Nombre, tipo de ejecutable (Cliente o Servidor) y la ruta física del archivo.

8. Parámetros: Guarda los datos necesarios que se utilizarán al iniciar cada uno de los ejecutables de la aplicación, posee los atributos nombre y valor. 

9. Nodos: La tabla nodos indica la cantidad de nodos que se encuentran disponibles en la infraestructura para desplegar los ejecutables de una aplicación, posee los atributos: Ip del nodo, nombre de usuario y contraseña para iniciar sesión en el sistema operativo.

10. Mensajes agente: Permite guardar toda la información proveniente del agente de configuración alojado en un nodo particular, sus atributos son: Id proceso, cantidad de procesos, memoria disponible, uso cpu, puertos en uso, nombre de la aplicación actual y estado de la aplicación (chequear).

11. Mensaje entre nodos: Almacena los mensajes enviados por un nodo a través de la librería de mensajes. Sus atributos son: Fecha, hora y mensaje.

12. Ejecutable nodo (E_N): Permite asociar los mensajes de un ejecutable particular de una aplicación junto a su número de proceso, posee los atributos fecha de despliegue, hora de despliegue y número de proceso.

13. Evento: La tabla permite generar los distintos eventos disponibles para los ejecutables de las aplicaciones, posee los atributos nombre del evento y dirección del script (opcional).

14. Ejecutable evento (E_E): Asocia los eventos disponibles para un ejecutable particular (Intersección).

 

 
Scripts:

Se crearon scripts de sistema operativo que permitieran enviar instrucciones desde el módulo de ciclo de vida hacia cada uno de los nodos del sistema distribuido, para ello es utilizó el protocolo Secure Shell (SSH) que permite conectarse de manera segura de un host a otro. Se generó un par de llaves (pública y privada) desde el host donde se ubicará el servidor central, se envía la llave pública a cada Raspberry Pi almacenandose en el directorio ".ssh/authorized_keys'. Esto permite el inicio de sesión desde el host con la llave privada (servidor central) sin la necesidad de introducir contraseña de usuario. La autenticación se realiza mediante <llave privada / llave pública>.

Los scripts creados son los siguientes:

1. Ejecutar.sh: Se creó un script de ejecución que permitiera copiar un ejecutable (.jar) ubicado en el servidor central hacia un nodo específico del sistema distribuido y luego permitir su ejecución junto a los parámetros propios de la aplicación. El script contiene el nombre de usuario con el que se conectará al host, su dirección ip, la ruta y nombre del archivo a copiar y los parámetros de dicha aplicación. Se hace uso de los comandos secure copy (SCP) y secure shell (SSH).

2. EliminarNodo.sh: Un script de eliminar un nodo permite detener el proceso asociado a la ejecución del ejecutable. Se debe conocer el número de proceso del ejecutable actual, para ello, cada aplicacion al ejecutarse envia su numero de proceso al servidor central de manera que se tenga registrado cada ejecutable con su respectivo numero de proceso. El script hace uso del comando kill -9 <numero_de_proceso> lo que conlleva a detener el proceso.

3. EliminarTodos.sh: Este script permite eliminar el ejecutable en acción de cada nodo lo que permite dejar el sistema sin ninguna aplicación en ejecución. Contiene la información de cada usuario, ip e id de proceso del ejecutable actual.



Librería:

Historias de Usuarios: Para el desarrollo de la librería de recepción de mensajes se crearon las historias de usuarios para obtener los requerimientos principales: Envío y recepción de mensajes simples:

1. Atributos Configurables: La librería posee atributos que pueden ser configurados en cualquier momento: puerto de escucha, cantidad máxima de mensajes a recibir, dirección ip de origen del mensaje, dirección ip de los destinatarios del mensaje.

2. Mensajes simples: La librería debe permitir enviar mensajes a través de un método donde se indique el mensaje a enviar.

3. Fecha y hora del mensaje: Los mensajes recibidos a través de la librería deben contener la fecha y hora del momento en el que fue enviado.

4. Información del agente: La librería permite enviar mensajes de los agentes de configuración para ser capturados por el servidor central.

Diseño:
Tarjetas CRC:

Se crearon cuatro (4) clases:

1. LibreriaMensaje:
	- Responsabilidad:
		1. Almacenar los mensajes recibidos desde otro host.
		2. Envio de mensajes hacia uno o más hosts.
        - Colaboración: EscuchaMensajes.
2. EscuchaMensajes:
	- Responsabilidad:
		1. Establecer el puerto de escucha de los mensajes.
		2. Recibir mensajes de parte de otro host o agente.
	- Colaboración: Mensaje, InformacionAgente. 
3. Mensaje:
	- Responsabilidad:
		1. Almacenar la información que se enviará hacia un host (Fecha, hora, texto).

4. InformacionAgente:
	- Responsabilidad:
		1. Almacenar la información recopilada por los agentes de configuración.
	-Colaboración:
 
Codificación:

La codificación de la librería de mensajes se inició con la clase Mensaje, en ella, se encapsula los mensajes que serán enviados por los diferentes componentes de la infraestructura. Un objeto mensaje se crea  indicando el texto de la información a enviar y la dirección ip del host que enviará el mensaje, la fecha y la hora se obtiene de la clase Date que permite definir un formato particular, en este caso las fechas poseen el formato "dd/mm/aaaa" (Día, mes, año) mientras que la hora posee el formato "HH:mm:ss" (Horas, minutos, segundos).

La clase InformacionAgente contiene los atributos que el agente de configuración recolectará del Raspberry Pi: Procesos activos, memoria disponible, uso del cpu, dirección ip, puertos disponibles, aplicación activa, numero de nodo  e id proceso.

La clase EscuchaMensaje extiende de la clase Thread<cursiva>, posee un método iniciar<cursiva> donde se crea un ServerSocket que permite  escuchar por un puerto específico. Se implementa el método run que contiene un bucle infinito donde se esperan por los mensajes enviados por los componentes de la infraestructura o por los agentes de configuración. Al llegar un mensaje se comprueba el tipo de mensajes recibido: Si el mensaje pertenece a la clase "Mensaje" significa que es un mensaje de información enviado por otro host y es almacenado en la lista de mensajes recibidos, en caso contrario se almacena en la lista de mensajes de agentes, ambas listas se encuentran en la clase LibreriaMensaje.

La clase LibreriaMensaje inicia el comportamiento de la librería, posee los atributos: puerto, mensajes máximos, dirección ip origen y las listas de direcciones ip destino, mensajes recibidos y mensajes agente. Al instanciarse un objeto de LibreriaMensaje se inicia la escucha por medio de la clase EscuchaMensaje y el puerto indicado, por defecto el puerto de escucha posee el valor 1337 aunque también se puede iniciar con un puerto distinto o sin puerto (Solo para enviar mensajes, no recibir). Se hace llamado al método obtenerIp que permite conocer la dirección ip del host donde se está ejecutando la librería de mensajes. La clase posee el método enviarMensajes que permite enviar un mensaje (una cadena de caracteres) a uno o varios host, indicando o no el puerto de envío, estos métodos abren un socket al host y puerto indicado, envían el objeto correspondiente (Mensaje o InformacionAgente) y cierran el socket. Adicionalmente posee los métodos agregarMensajeRecibido que permite agregar un mensaje de otro host o del agente de configuración a la lista correspondiente el cual es invocado desde la clase EscuchaMensaje al recibir el objeto correspondiente validando que el tamaño de la lista de mensajes sea menor o igual a la cantidad máxima de mensajes (atributo de mensajes máximos), ultimoMensaje que retorna el último mensaje agregado a las listas, buscarMensaje que retorna un mensaje dado un indice de la lista y eliminarMensaje que borra un mensaje particular de las listas. Las listas poseen una cantidad máxima por defecto de cinco objetos, si se supera la cantidad máxima se elimina el objeto más antiguo de ellas. Se aprovecha la sobrecarga de métodos que proporciona la programación orientada a objetos debido a que los métodos enviarMensaje, buscarMensaje, ultimoMensaje, eliminarMensaje poseen distintos parámetros de invocación. 


Pruebas Unitarias: Se realizaron pruebas unitarias de los métodos enviarMensaje, obtenerIp, agregarMensajeRecibido y ultimoMensaje.
Pruebas de aceptación:






Agente de Configuración:


Historias de Usuario:

Para el agente de configuración se elaboraron las siguientes historias de usuario:

- Información sobre SO: Se requiere que el agente puede obtener información del sistema operativo: Uso del cpu, memoria disponible y procesos activos.
- Información de red: El agente obtiene información de la red donde se encuentra conectado: (dirección IP del host y puertos disponibles).
- Información de la aplicación actual: El agente recolecta información de la aplicación actual: Nombre de la aplicación y número de nodo.
- Inicio automático: Se requiere que el agente se inicie automático al iniciar cada nodo de manera que pueda recolectar y enviar la información correspondiente.
- Librería de mensajes: El agente debe contener la librería de mensajes para el envío de la información hacia el servidor central.

Diseño
Tarjetas CRC:

Se crearon dos clases:

1. AgenteConfiguración:
	-Responsabilidad:
		1. Inicializa la configuración del agente, librería de mensajes y dirección ip del servidor central.
	-Colaboración: Monitoreo.
	
2. Monitoreo:
	-Responsabilidad:
		1. Contiene los métodos necesarios para la recolección de información de diferente tipo (Sistema operativo, red y aplicación actual).
	-Colaboración: InformacionAgente (Librería de mensajes).

Desarrollo:

El agente de configuración se desarrolló mediante una aplicación en java que se ejecuta al iniciar cada Raspberry Pi. La Clase AgenteConfiguracion posee el atributo lib que hace referencia a la librería de mensajes desarrollada, se indica el puerto de escucha de los mensajes, ip del servidor central e interfaz de red activa del Raspberry Pi antes de iniciar el monitoreo de la información. Al iniciarse la librería, se abre un puerto distinto al puerto de escucha por defecto  debido a que este último estará ocupado por la aplicación actual de sistema distribuido. El agente mediante la clase Monitoreo y comandos del sistema operativo (UNIX / Linux) obtiene las siguientes informaciones: 

Información del sistema operativo: 

- Cantidad de procesos: El método procesosActivos utiliza el comando ps -e <cursiva> permite obtener el número de procesos que se encuentran activos en el sistema operativo, esta cantidad se totaliza  y se retorna el número calculado.
- Memoria disponible: Para la cantidad de memoria disponible en el sistema se creó un método llamado memoriaDisponible y mediante el comando free -m <cursiva>  se obtiene el valor actual en Megabytes (MB)  de la memoria del sistema operativo.

- Uso del cpu: El método usoCpu utiliza el comando ps -eo pcpu<cursiva> que muestra la cantidad de procesador que está utilizando para cada proceso activo en el sistema operativo, esta cantidad es totalizada y se retorna su valor.

Información de red:
-Dirección Ip: La dirección ip del Raspberry es obtenida a través del metido direccionIp, este utiliza el comando ifconfig que muestra todas las interfaces de red disponibles en el sistema. Al iniciar el agente se indica la interfaz de red de donde se obtendrá la dirección ip: eth0, wlan1, entre otros.

-Puertos disponibles: El método puertosDisponibles obtiene los puertos que se encuentran activos en el Raspberry Pi, utilizando el comando nmap se realiza un exploración (scan) de todos los puertos abiertos en el computador. El resultado es obtenido en una lista con el  numero de puerto y su protocolo.

Información de la aplicación:

-Aplicación activa: El agente mediante el método comprobarAplicacionActiva chequea si puede enviar mensajes al puerto predeterminado de mensajes (1337), si es posible realizar la conexión entonces el método aplicacionActiva envía un mensaje a la aplicación preguntando por el nombre de ella, la aplicación responde al mensaje del agente y le envía su nombre. En caso contrario no se realiza ninguna petición.

-Número de nodo: El agente adicionalmente envía un mensaje preguntando por el número de nodo de la aplicación que se está ejecutando en el Raspberry Pi. La aplicación responde al agente enviando un número de acuerdo al nodo activo para esa aplicación.

El agente de configuración al recolectar cada información construye un objeto de tipo InformacionAgente que contiene atributos relacionados a cada tipo de información: uso cpu, memoria disponible, puertos, ip, entre otros. Al finalizar de construir el objeto con la información recolectada se envía al servidor central el objeto para ser redirigido al módulo de monitoreo y almacenar la información en base de datos. Este proceso ocurre cada "cinco" segundos.


Pruebas Unitarias: Se realizaron pruebas unitarias de los métodos de monitoreo: procesosAcivos, usoCpu, direccionIp, puertosDiponibles, aplicacionActiva y numeroNodo.
Pruebas aceptación:

Servicio de recepción (Servidor Central):

Historias de Usuario:

- Reenvío de los mensajes: Se requiere que el servidor central permite recibir los mensajes por parte de las aplicaciones de sistema distribuidos y de los agentes de configuración para ser reenviados al módulo de monitoreo.

- Repositorio Local: El servidor central debe contener un repositorio local donde se almacenen los ejecutables de las aplicaciones y los scripts de sistemas operativos.

- Ejecución de Scripts: El servidor central debe permitir ejecutar los scripts de sistemas operativos de manera que pueda desplegarse los ejecutables con sus parámetros en los respectivos nodos Raspberry Pi

- Conexión a la Base de Datos: El servidor central debe permitir conectarse a la base de datos de manera que se pueda recuperar los parámetros de  un ejecutable o insertar los mensajes enviados por un nodo o el agente de configuración.

- Nodos del sistema distribuido: El servidor central debe contener información de los nodos que se encuentran activos de manera que se pueda detener su ejecución cuando el usuario lo indique desde el módulo de ciclo de vida.

Diseño:
Tarjetas CRC:

Se crearon cuatro clases:

1. ConexionBD:
	- Responsabilidad: 
		1.Realizar las llamadas a la base de datos para generar consultas asociadas a la ejecución o detención de las aplicaciones de sistemas distribuidos.
		2. Insertar la información perteneciente a los mensajes recibidos por parte de las aplicaciones, agentes de configuración.
2. NodoActivo
	- Responsabilidad:
		1. Mantener la información perteneciente al nodo que se encuentra activo en una aplicación de sistema distribuido.

3. GestionarInfraestructura:
	- Responsabilidad:
		1. Realizar las operaciones de ejecución y eliminación de las aplicaciones.
		2. Redirigir los mensajes enviados de los mensajes de los nodos y de los agentes de configuración.
		3. Consultar la base de datos para obtener los parámetros de las aplicaciones, la información de cada nodo (ip, usuario, contraseña).
		4. Insertar en la base de datos la información correspondiente a los mensajes entre los nodos, el ejecutable actual en el nodo, la información de los agentes de configuración. 
	








El servidor central se desarrolló mediante una aplicación en java que chequea constantemente los mensajes recibidos a través de la librería de mensajes. Al llegar un mensaje se analiza si es un mensaje de un Agente o un mensaje proveniente de un nodo o del modulo de ciclo de vida. Si se recibe un mensaje proveniente del agente entonces el servicio de recepción recibe el mensaje, lo almacena en base de datos y se reenvía al modulo de monitoreo. En caso contrario, se evalúa el contenido del mensaje a través del método recibirMensaje de la siguiente manera:

